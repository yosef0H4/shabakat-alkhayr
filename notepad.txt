# React Component Fixes

## Component Export/Import Issues
- When a component is exported using `export default`, it must be imported without curly braces
- When a component is exported using named export `export function/const`, it must be imported with curly braces

Example:
```tsx
// Export:
export default function ComponentName() {...}
// Import:
import ComponentName from './ComponentName';

// Named export:
export function ComponentName() {...}
// Import:
import { ComponentName } from './ComponentName';
```

## TypeScript Type Safety
- Always define types for variables that will be assigned dynamic values from JSON parsing
- When setting state with a value that must match a specific union type, use type assertion with 'as'

Example:
```tsx
// Type for parsed JSON
let parsedData: SomeType | undefined;

// Type assertion for union types
setValue(value as "specificType" | "anotherType");
```

## Navigation Component Updates
- To add a new route/view to the bottom navigation:
  1. Add a new button with onClick handler: `onClick={() => onNavigate("routeName")}`
  2. Set proper active state: `className={`tab-item ${currentView === "routeName" ? "active" : ""}`}`
  3. Add accessibility attribute: `aria-current={currentView === "routeName" ? "page" : undefined}`
  4. Include appropriate icon and translation key

## React Infinite Loop / Maximum Update Depth Error
- Error occurs when a component is repeatedly re-rendering without a proper stopping condition
- Common causes include:
  1. `useEffect` updating a state variable that's in its own dependency array
  2. Direct state updates inside render method
  3. Using arrays/objects directly in state updates without creating new copies
  4. Derived state that changes on every render (creating new arrays/objects in the component body)

- Solutions:
  1. Make sure to provide a dependency array to `useEffect` hooks
  2. When dealing with reference types (arrays/objects) in props or state, create a new copy to break reference equality
  3. Use callback form for state updates when based on previous state: `setState(prev => ...)`
  4. For objects from props that might cause re-renders, make a deep copy: `setSelectedItems([...currentItems])`
  5. Use `useMemo` for derived state to prevent recreating arrays/objects on every render:
  ```tsx
  // Bad - new array created on every render, can cause infinite loops
  const derivedItems = sourceItems ? sourceItems.map(item => item.value) : [];
  
  // Good - array only recreated when sourceItems changes
  const derivedItems = useMemo(() => {
    return sourceItems ? sourceItems.map(item => item.value) : [];
  }, [sourceItems]);
  ```

## Convex Environment Variables Setup
- To add environment variables in Convex (like GEMINI_API_KEY):
  1. Go to Convex Dashboard > Deployment Settings > Environment Variables section
  2. Add a new environment variable with name `GEMINI_API_KEY` and your API key as the value
  3. Alternative: Use CLI command: `npx convex env set GEMINI_API_KEY your-api-key-here`
  4. Environment variables are set per-deployment (add to both dev/prod if needed)
  5. Access in Convex functions with: `process.env.GEMINI_API_KEY`

- Getting a Gemini API key:
  1. Visit Google AI Studio (https://ai.google.dev/)
  2. Create/sign in to your account
  3. Get an API key from the API keys section

# Chatbot Conversation Flow Fix

## Issue
When using a chatbot with a state-based conversation flow, the bot was getting stuck in a loop because:
1. The UI component (`ChatPage.tsx`) was correctly setting state (post_type), but
2. The backend processing function (`generateDevelopmentResponse` in `chatbot.ts`) was trying to extract the info from the message text again and not properly respecting already-set state

## Solution
1. Added checks to only extract info if it's not already set in the state:
   ```typescript
   if (!postInfo.post_type && (userMessage.toLowerCase().includes("need help"))) {
     extractedInfo = { ...postInfo, post_type: "helpNeeded" };
   }
   ```

2. Updated the response generation logic to check both the existing state and newly extracted info:
   ```typescript
   else if (!postInfo.post_type && !extractedInfo?.post_type) {
     // No post type selected yet
     responseMessage = "Welcome message...";
   }
   ```

3. Used fallback values from both sources when generating dynamic responses:
   ```typescript
   const postType = postInfo.post_type || extractedInfo?.post_type;
   responseMessage = `Great! What would you like to title your ${postType === "helpNeeded" ? "help request" : "help offer"}?`;
   ```

This approach ensures the conversation flow progresses properly through each step and doesn't get stuck repeating the same prompts.

# Gemini API Integration

## Implementation Steps
1. The Gemini API requires an API key from Google AI Studio (https://ai.google.dev/)
2. Set up the environment variable `GEMINI_API_KEY` in your Convex deployment
3. Make the API call to the Gemini API endpoint:
   ```typescript
   const response = await fetch("https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent", {
     method: "POST",
     headers: {
       "Content-Type": "application/json",
       "x-goog-api-key": apiKey
     },
     body: JSON.stringify({
       contents: [{
         parts: [{
           text: promptText
         }]
       }],
       generationConfig: {
         temperature: 0.4,
         topK: 32,
         topP: 0.95,
         maxOutputTokens: 1024,
       }
     })
   });
   ```

## Response Parsing
- Gemini responses need to be parsed to extract:
  1. The main message text
  2. Any structured data (like post information)
  3. Option buttons for user choices

- Regex patterns for extracting JSON from markdown code blocks:
  ```typescript
  // Extract JSON object
  const dataMatch = text.match(/```json\s*({[\s\S]*?})\s*```/);
  
  // Extract JSON array
  const arrayMatch = text.match(/```json\s*(\[[\s\S]*?\])\s*```/);
  ```

- Clean the response text by removing code blocks and special instructions:
  ```typescript
  const cleanedResponse = aiResponse
    .replace(/```json[\s\S]*?```/g, '')
    .replace(/```[\s\S]*?```/g, '')
    .replace(/\[EXTRACT_INFO[\s\S]*?\]/gi, '')
    .trim();
  ```

## Prompt Engineering
- Structuring prompts for AI assistants:
  1. Start with a clear role definition
  2. Provide conversation history for context
  3. Include current state information
  4. Give explicit instructions on what to extract
  5. Use formatting expectations for structured data (like JSON)

# Using Convex Actions for External API Calls

## Issue
When trying to use `fetch()` or other networking functions in Convex mutations/queries, you'll encounter this error:
```
Error: Can't use fetch() in queries and mutations. Please consider using an action.
```

## Solution
External API calls in Convex must use actions instead of mutations or queries:

1. Create an action that makes the API call:
   ```typescript
   "use node"; // Required at the top of the file for Node.js functionality
   
   import { action } from "./_generated/server";
   
   export const callExternalAPI = action({
     args: { /* arguments */ },
     returns: v.object({ /* return type */ }),
     handler: async (ctx, args) => {
       // Make API call with fetch()
       const response = await fetch("https://api.example.com");
       // Process response
       return processedData;
     }
   });
   ```

2. Call the action from a mutation using the scheduler:
   ```typescript
   import { mutation } from "./_generated/server";
   import { internal } from "./_generated/api";
   
   export const processSomething = mutation({
     args: { /* arguments */ },
     returns: v.object({ /* return type */ }),
     handler: async (ctx, args) => {
       // Call the action
       return await ctx.scheduler.runAfter(0, internal.yourfile.callExternalAPI, {
         // arguments to pass
       });
     }
   });
   ```

## Key Points
1. Always add `"use node";` at the top of files containing actions
2. Actions cannot access the database directly via `ctx.db`
3. To call an action from another Convex function, use `ctx.scheduler.runAfter()`
4. When defining functions, always specify return types with `returns: v.object({...})`

# Fixing TypeScript Circularity Errors in Convex

## Issue
When using Convex's API with TypeScript, you may encounter circularity errors like:
```
'generateGeminiResponse' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.
```
```
'handler' implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.
```

These errors occur when TypeScript can't resolve type references that appear to be circular.

## Solutions

1. **Create an explicit interface for response types**:
   ```typescript
   export interface GeminiResponseType {
     message: string;
     extractedInfo?: string | null;
     options?: string | null;
     readyForSubmission?: boolean;
   }
   ```

2. **Add explicit return type annotations to handler functions**:
   ```typescript
   handler: async (ctx, args): Promise<GeminiResponseType> => {
     // Function body
   }
   ```

3. **Store intermediate values in variables with explicit types**:
   ```typescript
   const result = await ctx.scheduler.runAfter(0, internal.chatbot.callGeminiAPI, {
     // args
   });
   
   return result;
   ```
   Instead of:
   ```typescript
   return await ctx.scheduler.runAfter(0, internal.chatbot.callGeminiAPI, {
     // args
   });
   ```

4. **For Convex actions with network calls**:
   - Use `"use node";` at the top of the file
   - Define functions as actions with `action()` instead of mutations
   - Call actions from mutations using `ctx.scheduler.runAfter()`

# Convex Actions and Scheduled Functions Limitations

## Actions and the Scheduler Issue

When implementing external API calls in Convex (like calling the Gemini API), we need to use Actions instead of Mutations/Queries since Actions can make network requests. However, there are some important limitations to keep in mind:

1. Actions must be called using `ctx.scheduler.runAfter()` from mutations
2. Actions cannot directly return values to mutations
3. The return value of `ctx.scheduler.runAfter()` is an ID of the scheduled function, not the actual result

### Key Issue: TS Error When Trying to Access Action Results

We encountered this error when trying to retrieve the results of a scheduled action:
```
Property 'chatbot' does not exist on type '{ auth: { store: ... } }'
Property 'result' does not exist on type '{...}'
```

This happens because TypeScript doesn't know how to properly type the relationship between the scheduler and the action results.

## Solutions

### Option 1: Fallback Development Mode

The simplest solution for development is to create a fallback function that simulates the response of the external API. This avoids the need to call the action entirely.

```typescript
// Check for API key in environment variables
const apiKey = process.env.GEMINI_API_KEY;
if (!apiKey) {
  // For development without API key, provide a fallback response
  console.warn("No Gemini API key found, using development fallback");
  return generateDevelopmentResponse(args.userMessage, args.postInfo, args.conversationContext);
}
```

### Option 2: Better Architecture for Production

A more robust approach for production would be:

1. Use actions purely for their side effects (making the external API call)
2. Have actions store their results in a database table
3. Use mutations to check for and retrieve these results

For example:
```typescript
// In the action
const result = await callGeminiAPI();
await ctx.runMutation(internal.messages.storeResult, { 
  messageId: args.messageId, 
  result 
});

// In a separate mutation
export const getActionResult = mutation({
  handler: async (ctx, args) => {
    return await ctx.db.query("actionResults")
      .filter(q => q.eq(q.field("messageId"), args.messageId))
      .first();
  }
});
```

## Resources

- Convex documentation on Actions: https://docs.convex.dev/functions/actions
- Convex documentation on Scheduled Functions: https://docs.convex.dev/scheduling/scheduled-functions
- Convex documentation on Internal Functions: https://docs.convex.dev/functions/internal-functions

# Client-Side Gemini API Implementation

## Architecture Overview
- Main component: `ChatPage.tsx`
- Supporting components:
  1. `ChatMessage.tsx` - Renders individual chat messages
  2. `ChatInput.tsx` - Input component for sending messages
  3. `PostPreview.tsx` - Preview component for structured data output

## Key Components

### 1. API Key Management
- Uses localStorage to securely store API keys client-side
- Includes consent dialog with clear disclaimers
- Allows users to remove stored API keys
- Leverages terms of service acceptance requirement

```typescript
// Load API key from localStorage
useEffect(() => {
  const storedKey = localStorage.getItem("gemini_api_key");
  if (storedKey) {
    setApiKey(storedKey);
    setIsKeyStored(true);
  }
}, []);

// Store API key
localStorage.setItem("gemini_api_key", apiKey);
```

### 2. Gemini API Integration
- Uses the official `@google/generative-ai` package
- Configures the Gemini 2.0 Flash model
- Maintains conversation history between chat turns
- Error handling for API failures

```typescript
const genAI = new GoogleGenerativeAI(apiKey);
const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });
      
// Prepare conversation history
const history = messages.map(m => ({
  role: m.role,
  parts: [{ text: m.content }]
}));
      
// Start a chat session
const chat = model.startChat({ history });
      
// Generate response
const result = await chat.sendMessage(message);
const response = result.response.text();
```

### 3. Structured Data Extraction
- Parses JSON output from chatbot responses
- Extracts post data for preview/submission
- Uses regex pattern matching to find JSON structures

```typescript
const extractPostData = (text: string) => {
  try {
    // Look for JSON-like structure in the text
    const jsonMatch = text.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      const jsonStr = jsonMatch[0];
      const data = JSON.parse(jsonStr);
      
      // Check if this appears to be a post
      if (data.title && data.description) {
        setPostData(data);
      }
    }
  } catch (error) {
    console.log("No valid JSON found in response");
  }
};
```

## Security Considerations
1. API keys are stored only in client-side localStorage
2. Keys are never transmitted to our servers
3. Communication is directly between client and Google's API
4. Clear disclaimers about usage costs and responsibility
5. Users can delete stored API keys at any time
6. Terms of service acceptance required

## Implementation Requirements
1. Install the Google Generative AI package:
   ```bash
   npm install @google/generative-ai
   ```
2. Update translations with the new chat-related strings
3. Add the chat route to the Navigation and App components
4. Create all required React components

## Error Handling
- Toast notifications for common errors
- Loading states for API requests
- Fallbacks when API key is missing
- Console error logging for debugging

# Navigation Component Array-based Structure

## Implementation
Successfully refactored the Navigation component to use an array-based structure for nav items:
```typescript
const navItems = [
  {
    id: "feed",
    label: t('nav.feed'),
    icon: (/* SVG component */)
  },
  // ... other items
];

// Usage in JSX
{navItems.map((item) => (
  <button
    key={item.id}
    onClick={() => onNavigate(item.id)}
    className={`tab-item ${currentView === item.id ? "active" : ""}`}
    aria-current={currentView === item.id ? "page" : undefined}
  >
    {/* button content */}
  </button>
))}
```

## Benefits
1. More maintainable - adding/removing nav items only requires modifying the array
2. DRY - removes repeated button structure
3. Consistent styling and behavior across all nav items
4. Type-safe with TypeScript through the array structure

## Key Points
1. Each nav item needs: id, label, and icon
2. Use translation keys for labels (t('nav.keyname'))
3. Icons should use consistent styling (stroke-width, viewBox, etc.)
4. Maintain accessibility with aria-current attribute

# Maximum Update Depth Exceeded Fix in FilterDialog.tsx

## Issue
The component was triggering an infinite update loop with the error:
```
Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.
```

## Root Cause
Using `useEffect` with `setState` to filter suggestions was creating a cycle:
1. Component renders
2. `useEffect` runs and calls `setFilteredSuggestions`
3. State update causes re-render
4. `useEffect` runs again because its dependencies changed
5. Repeats infinitely

## Solution
Replace `useEffect` + `setState` with `useMemo` for derived state:

```tsx
// BAD: Causes infinite loop
const [filteredSuggestions, setFilteredSuggestions] = useState<string[]>([]);
useEffect(() => {
  if (input.trim()) {
    const filtered = items.filter(item => item.includes(input));
    setFilteredSuggestions(filtered);
  } else {
    setFilteredSuggestions([]);
  }
}, [input, items]);

// GOOD: Calculates derived state without causing re-renders
const filteredSuggestions = useMemo(() => {
  if (input.trim()) {
    return items.filter(item => item.includes(input));
  }
  return [];
}, [input, items]);
```

This approach is more efficient because:
1. It doesn't trigger extra render cycles
2. The value is only recalculated when dependencies change
3. It follows React's data flow principles for derived state

**Important:** Always use `useMemo` instead of `useEffect` + `setState` when the state is derived from existing props or state.

# Gemini API Implementation Notes

## Model Names (as of March 2024)
- gemini-pro: The main text model for chat and text generation
- gemini-pro-vision: For multimodal (text + image) tasks
- Note: The "gemini-2.0-flash" and "gemini-2.0-flash-live" models are deprecated

## Best Practices
1. Direct Content Generation:
   - Use `generateContent()` for simple text generation
   - More reliable than chat sessions for basic interactions
   - Example:
     ```typescript
     const model = genAI.getGenerativeModel({ model: "gemini-pro" });
     const result = await model.generateContent(message);
     const response = await result.response;
     const text = response.text();
     ```

2. Error Handling:
   - Common errors to handle:
     - "API key not valid"
     - "quota exceeded"
   - Always provide user-friendly error messages
   - Clear API key if it becomes invalid

3. UI/UX Considerations:
   - Show loading states during generation
   - Auto-scroll to latest messages
   - Empty state message when no chat history
   - Disable input while generating
   - Secure API key input with show/hide toggle

4. Security:
   - Store API key in localStorage
   - Never expose API key in client-side code
   - Consider server-side proxy for production

## Translation Keys Required
- chat.startPrompt
- chat.inputPlaceholder
- chat.apiKeyPlaceholder
- chat.invalidApiKey
- chat.quotaExceeded
- chat.apiError
- chat.emptyApiKey
- chat.mustAcceptTerms
- chat.apiKeySaved
- chat.noApiKey
- chat.apiKeyRequired
- chat.apiKeyExplanation
- chat.enterApiKey
- chat.acceptTerms
- chat.saveApiKey
- chat.typeMessage
- chat.generating
- chat.send
